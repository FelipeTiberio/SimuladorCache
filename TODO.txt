Lista de implementação e mudanças desde 9 de junho de 2018.

 	COISAS QUE TENHO DE FAZER :
1. Implementação dos tipos de mapemamentos: [x]
	-> Direto [x]
	-> Totalmente associativo [x]
	-> Parcialmente associativo [x]

2. Número do conjunto [x](Fazer emm conjunto com o mapeamento parcialmente associativo ) 
	-> Cada bloco na memória tenho um atributo dizendo qual é o seu set [x]

3. Políticas de substituições []
	-> Aleatório [x]
	-> FIFO [x] 
	-> LFU  []
	-> LRU  [] (Funcina parcialmente, apenas para a política de sub totalmente associativa)
	-> UM SOLUÇÃO QUE PODE FUNCIONAR, FAZER COM QUE CADA LINHA NA CACHE JÁ SAIBA EM QUE CONJUNTO ELA ESTARÁ
	   ASSIM A CACHE FICARA MENOR E NÃO PRECISSAREI FAZER SEMPRE OS CÁLCULOS PARA SABE QUEM PERNTENCE AQUE CONJUNTO.
	   POSSO USAR UM MÉTODO QUE RETORNA  A QUAL CONJUNTO UMA DETERMINADA LINHA PERTENÇA, OU UM ATRIBUTO QUE JÁ GUARDE 
	   O SET.[x

4. Políticas de escrita []
	-> write-back []
	-> write-through []

5. Uma classe sistema que gerenciará todos os itens acima, assim a implementação 
 não precisará está de forma confusa e solta no main.[x]

	COISAS QUE FAREI CASO EXISTA TEMPO :

6. colocar guarda e tratar algumas entradas do usuário como erro [].

1. No caso de im política de substituíção por conjunto 
   imprime um marcador de onde começa e termina cada conjunto [].

2. O vector de linhas na cache, bem como, o vector de blocos estão públicos em suas classe,
fiz isso porque assim era mais fácil de imprementar os acessos do sistemas a esses membros.
(Caso exista tempo, antes de mandar ao professor corrigir isso). Solução que pode funcionar:
Colocar a classe sistema como friend das classes memoria e cahce[].

3.Implementar um membro na classe sistema, ou na cache mesmo que diga quando ocorre cache hits:
COMO FUNCIONARÁ;
 Quando digita read de um endereço na memorio o atributo o atributo será verdade quando quando o bloco 
 já estiver na memória, será falso caso contrário.[]
